<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.co.hanipaction.application.order.OrderMapper">



    <insert id="save" useGeneratedKeys="true" keyProperty="id" >
        INSERT INTO orders
        SET user_id = #{userId}
        , store_id = #{storeId}
        , address = #{address}
        , amount = #{amount}

    </insert>

    <!--   요구사항명세서 : 주문조회  -->
<!--    결제수단 추가예정-->
    <select id="findByOrderIdAndUserId">
        SELECT o.id, o.user_id, s.`name`AS storeName, o.store_id AS storeId
        , o.amount, o.`status`, o.created, s.image_path, o.is_deleted
        FROM orders o
        JOIN stores s ON o.store_id = s.id
        JOIN users u ON o.user_id = u.id
        WHERE o.user_id = #{userId}
        AND is_deleted = 0
        ORDER BY o.created DESC
    </select>

<!--  주문상세조회-->
    <select id="findById">
        SELECT o.id,o.user_id,s.`name`AS storeName,o.store_id AS storeId ,m.`name` AS menuName ,om.quantity,m.price,o.amount,o.`status`
        FROM orders o
        JOIN order_menus om
        ON o.id = om.order_id
        LEFT JOIN stores s
        ON o.store_id = s.id
        JOIN menus m
        ON om.menu_id = m.id
        WHERE o.id = #{id} ;
    </select>

<!--일단 위에랑 동일 -->


<!--   주문상태변경-->
    <update id="updateStatus">
        UPDATE orders
        SET `status` = #{status}
        WHERE	id = #{orderId};
    </update>
<!-- 주문 삭제 -->
    <update id="hideByOrderId">
        UPDATE orders
        SET is_deleted = 1
        WHERE	id = #{orderId}
    </update>

    <select id="findOrderByStoreId">
        SELECT o.id, o.user_id, s.name AS storeName,
        u.name AS userName, o.amount, o.status, s.id AS storeId,
        o.address, o.postcode, o.address_detail, o.created, o.updated, u.phone,
        o.is_deleted
        FROM orders o
        JOIN users u ON o.user_id = u.id
        JOIN stores s ON s.id = o.store_id
        WHERE o.store_id = #{storeId}
        ORDER BY o.updated DESC
    </select>

    <select id="findByStoreIdAndDate">
        SELECT o.id, o.user_id, s.name AS storeName,
        u.name AS userName, o.amount, o.status, s.id AS storeId,
        o.address, o.postcode, o.address_detail, o.created, o.updated, u.phone,
        o.is_deleted
        FROM orders o
        JOIN users u ON o.user_id = u.id
        JOIN stores s ON s.id = o.store_id
        WHERE o.store_id = #{storeId}
        <if test="startDate != null and endDate != null">
            AND o.created BETWEEN #{startDate} AND #{endDate}
        </if>
        ORDER BY o.updated DESC
    </select>

<!---->
<!-- 신규 추가 맵퍼-->


    <!-- 주문내역 인피니티, 페이지네이션용-->
    <select id="findOrders">
        SELECT o.created_at, o.`status`,o.amount AS totalPrice, o.store_name, om.menu_name , o.store_id, o.id AS orderId
        FROM orders o
        JOIN orders_menu om
        ON o.id = om.order_id
        <where>
        o.is_deleted = 0
        AND o.`status` !=  '01'
            AND o.user_id = #{userId}
        <if test="storeName != null">
        AND o.store_name LIKE CONCAT('%', #{storeName}, '%')
        </if>
        <if test="menuName != null">
        AND om.menu_name LIKE  CONCAT('%', #{menuName}, '%')
        </if>
            <if test="startDate != null and endDate != null">
                AND o.created_at BETWEEN CONCAT(#{startDate}, ' 00:00:00')
                AND CONCAT(#{endDate}, ' 23:59:59')
            </if>
        </where>
        GROUP BY o.id
        ORDER By o.id DESC
        LIMIT #{startIdx}, #{size}
    </select>

<!--    사장용 주문 대기 조회 -->
    <select id="findOrdered">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE o.`status` = '02'
        AND o.store_id = #{storeId}
        ORDER BY o.created_at DESC;
    </select>
<!--    사장용 음식 조리대기 조회-->
    <select id="findPreParing">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE o.`status` = '03'
        AND o.store_id = #{storeId}
        ORDER BY o.created_at DESC;
    </select>
<!--    배달중과 배달 완료 조회 / 프론트에서 보여지는 화면은 createAt이용해서 하루마다 초기화 해야할듯-->
    <select id="findDelivered">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE o.`status` = '04'
        OR o.`status` = '05'
        AND o.store_id = #{storeId}
        ORDER BY o.created_at DESC;
    </select>

    <select id="findCompleted">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE o.`status` = '05'
        AND o.store_id = #{storeId}
        ORDER BY o.created_at DESC;
    </select>

    <select id="findCanceled">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE o.`status` = '06'
        AND o.store_id = #{storeId}
        ORDER BY o.created_at DESC;
    </select>

    <select id="findOrderSearchByDate">
        SELECT *, o.id AS order_id
        FROM orders o
        WHERE (o.`status` = '05' OR o.`status` = '06')
        <if test="startDate != null and endDate != null">
            AND o.created_at BETWEEN #{startDate} AND #{endDate}
        </if>
        <if test="keyword != null and keyword != ''">
            <choose>
                <when test="searchType == 'address'">
                    AND o.address LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <when test="searchType == 'phone'">
                    AND o.user_phone LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <otherwise>
                    AND (
                    o.address LIKE CONCAT('%', #{keyword}, '%')
                    OR o.user_phone LIKE CONCAT('%', #{keyword}, '%')
                    OR o.user_name LIKE CONCAT('%', #{keyword}, '%')
                    )
                </otherwise>
            </choose>
        </if>
        ORDER BY o.created_at DESC
        LIMIT #{startIdx}, #{size}
    </select>

<!-- 배달원이 조회할 것 메뉴랭스는 특정 메뉴 외 더 시킨 것 ' 치킨 메뉴 외 2건 ' -->
    <select id="findDrOrderList">
        SELECT o.id AS order_id, o.store_id, o.store_name, o.address AS userAddress, o.address_detail AS user_address_detail, om.menu_name, o.amount,o.store_request,
        (SELECT COUNT(o.id)-1) AS menu_length
        FROM orders o
        LEFT JOIN orders_menu om
        ON o.id = om.order_id
        WHERE o.`status`= 2
        GROUP BY o.id
    </select>

    <!-- 주문 건 수 통계 -->
    <select id="findStatsByDate">
        <choose>
            <!-- 연간(2년 전, 1년 전, 올해) -->
            <when test="type == 'YEAR'">
                WITH years AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS year
                </foreach>
                )
                SELECT y.year AS period,
                       COUNT(o.id) AS total,
                       COUNT(CASE WHEN o.status = '05' THEN 1 END) AS cancelled
                FROM years y
                LEFT JOIN orders o
                ON YEAR(o.created_at) = y.year
                GROUP BY y.year
                ORDER BY y.year ASC
            </when>

            <!-- 월간(2달 전, 1달 전, 이번 달) -->
            <when test="type == 'MONTH'">
                WITH months AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS month
                </foreach>
                )
                SELECT DATE_FORMAT(m.month, '%Y-%m') AS period,
                       COUNT(o.id) AS total,
                       COUNT(CASE WHEN o.status = '05' THEN 1 END) AS cancelled
                FROM months m
                LEFT JOIN orders o
                ON DATE_FORMAT(o.created_at, '%Y-%m-01') = m.month
                GROUP BY m.month
                ORDER BY m.month ASC
            </when>

            <!-- 주간(2주 전, 1주 전, 이번 주) -->
            <when test="type == 'WEEK'">
                WITH weeks AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS week_start
                </foreach>
                )
                SELECT DATE_FORMAT(w.week_start, '%x-W%v') AS period,
                       COUNT(o.id) AS total,
                       COUNT(CASE WHEN o.status = '05' THEN 1 END) AS cancelled
                FROM weeks w
                LEFT JOIN orders o
                ON DATE(DATE_SUB(o.created_at, INTERVAL WEEKDAY(o.created_at) DAY)) = w.week_start
                GROUP BY w.week_start
                ORDER BY w.week_start ASC
            </when>

            <!-- 일간(2일 전, 1일 전, 오늘) -->
            <otherwise>
                WITH days AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS day
                </foreach>
                )
                SELECT d.day AS period,
                       COUNT(o.id) AS total,
                       COUNT(CASE WHEN o.status = '05' THEN 1 END) AS cancelled
                FROM days d
                LEFT JOIN orders o
                ON DATE(o.created_at) = d.day
                GROUP BY d.day
                ORDER BY d.day ASC
            </otherwise>
        </choose>
    </select>

    <!-- 매출액 통계 -->
    <select id="findAmountStatsByDate">
        <choose>
            <!-- 연간(2년 전, 1년 전, 올해) -->
            <when test="type == 'YEAR'">
                WITH years AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS year
                </foreach>
                )
                SELECT y.year AS period,
                       SUM(CASE WHEN o.status != '05' THEN o.amount ELSE 0 END) AS totalAmount
                FROM years y
                LEFT JOIN orders o
                ON YEAR(o.created_at) = y.year
                GROUP BY y.year
                ORDER BY y.year ASC
            </when>

            <!-- 월간(2달 전, 1달 전, 이번 달) -->
            <when test="type == 'MONTH'">
                WITH months AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS month
                </foreach>
                )
                SELECT DATE_FORMAT(m.month, '%Y-%m') AS period,
                       SUM(CASE WHEN o.status != '05' THEN o.amount ELSE 0 END) AS totalAmount
                FROM months m
                LEFT JOIN orders o
                ON DATE_FORMAT(o.created_at, '%Y-%m-01') = m.month
                GROUP BY m.month
                ORDER BY m.month ASC
            </when>

            <!-- 주간(2주 전, 1주 전, 이번 주) -->
            <when test="type == 'WEEK'">
                WITH weeks AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS week_start
                </foreach>
                )
                SELECT DATE_FORMAT(w.week_start, '%x-W%v') AS period,
                       SUM(CASE WHEN o.status != '05' THEN o.amount ELSE 0 END) AS totalAmount
                FROM weeks w
                LEFT JOIN orders o
                ON DATE(DATE_SUB(o.created_at, INTERVAL WEEKDAY(o.created_at) DAY)) = w.week_start
                GROUP BY w.week_start
                ORDER BY w.week_start ASC
            </when>

            <!-- 일간(2일 전, 1일 전, 오늘) -->
            <otherwise>
                WITH days AS (
                <foreach collection="periods" item="period" separator=" UNION ALL ">
                    SELECT #{period} AS day
                </foreach>
                )
                SELECT d.day AS period,
                       SUM(CASE WHEN o.status != '05' THEN o.amount ELSE 0 END) AS totalAmount
                FROM days d
                LEFT JOIN orders o
                ON DATE(o.created_at) = d.day
                GROUP BY d.day
                ORDER BY d.day ASC
            </otherwise>
        </choose>
    </select>


<!--    네이버페이용 -->

    <select id="naverPay">
        SELECT om.quantity AS menu_quantity, om.amount AS menu_price, o.amount AS total_price, om.menu_name, om.menu_id, o.user_id
        FROM orders o
        JOIN orders_menu om
        ON o.id = om.order_id
        WHERE o.user_id = #{userId}
        AND o.id = #{orderId}
        GROUP BY om.id
    </select>



</mapper>